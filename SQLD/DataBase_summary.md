# 데이터베이스 정리

<hr/><hr/>
### 데이터 모델링

- 업무 프로세스를 추상화하고, 분석·설계를 하는 과정

* 특징

  1. 추상화 : 간략하게 표한한다.

  2. 단순화 : 누구나 쉽게 이해할 수 있게 표현한다.

  3. 명확성 : 명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.

     

* 단계

  1. 개념적 모델링 

     - 프로세스를 분석석하여 데이터 모델링은 한다.
     - 엔터티와 속성을 도출하고 ERD를 작성한다.
     - 추상화 수준이 가장 높은 모델링이다.

  2. 논리적 모델링

     - 식벽자를 도출하고 모든 릴레이션을 정의한다.
     - 정규화를 통해 데이터 모델의 재사용성과 독립성을 높인다.

  3. 물리적 모델링

     - 성능, 보안, 가용성을 고려해서 데이터베이스를 실제로 구축한다.

       

* 관점

  - 데이터 : 프로세스에서 사용되는 데이터를 의미

  - 프로세스 : 프로세스에서 수행되는 작업을 의미

  - 데이터와 프로세스 : 프로세스와 데이터 간의 관계를 의미한다.

    

* ERD(Entity Relationship Diagram) 

  - 피터첸이 만든 표준 다이어그램으로 엔터티와 엔터티 간의 관계를 정의하는 모델링 방법

  - 작성 절차 : 이해하기 쉽고 복잡하기 않게 작성

    1. 엔터티를 도출하고 배치한다.

    2. 엔터티 간의 관계를 설정한다.

    3. 관계명을 서술한다.

    4. 관계 참여도(1:n)를 표현한다.

    5. 관계의 필수 여부를 표현한다.

       

* 고려사항

  1. 데이터 모델의 독립성 : 정규화를 통해 데이터 중복을 제거한다.
  2. 고객 요구사항 표현 : 간결하고 명확하게 표현한다.
  3. 데이터 품질 확보 :  데이터 표준을 정의하고 준수한다.

<hr/>
### 삼층 스키마(Three-Level Schema)

- 사용자, 설계자, 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들간의 관계를
  정의한  ANSI 표준이다.
- 데이터 독립성을 확보하기 위한 방법으로 중복 제거, 변경에 따른 대응력 향상, 
  관리 및 유지보수 비용 절감 등 장점을 가진다.

- 독립성
  1. 논리적 독립성 : 저장구조가 변경되어도 응용 프로그램 및 개념 스키마에 영향이 없다.
  2. 물리적 독립성 : 논리적 구조가 변경되어도 응용 프로그램에 변화가 없다.

- 구조
  1. 외부 스키마 : 사용자 관점으로 View를 표시하며, 응용 프로그램이 접근하는 데이터베이스를 정의한다.
  2. 개념 스키마 : 설계자 관점으로 규칙과 구조를 표현하며, 통합 데이터베이스 구조를 나타낸다.
  3. 내부 스키마 : 개발자 관점으로 데이터베이스 물리적 저장 구조이다.

<hr/>
### 엔터티(Entity)

- 데이터 집합을 의미하며, 저장되고 관리되아야 하는 데이터이다.

- 엔터티는 개념, 사건, 장소 등의 명사로 보면 된다.

- 도출 방법 : 비지니스 프로세스(업무 시나리오?)에서 관리되어야 하는 정보를 추출한다.

  

- 특징

  1. 식별자 : 유일한 식별자가 존재해야만 한다.
  2. 인스턴스 집합 : 2개이상의 인스턴스가 있어야 한다.
  3. 속성 : 반드시 속정을 가져야 한다.
  4. 관계 : 다른 엔터티와 최소 한 개 이상의 관계를 가져야한다.
  5. 업무 : 업무에서 관리되어야 하는 집합이다.

  

- 종류

  - 유형과 무형에 따른 엔터티 종류

    1. 유형 엔터티 : 물리적 형태가 존재하며, 지속적으로 사용되는 엔터티 ex) 고객, 강사

    2. 개념 엔터티 : 물리적 형태가 없으며, 개념적으로 사용되는 엔터티 ex) 종목, 보험상품

    3. 사건 엔터티 : 프로세스를 실행하면서 생기는 엔터티 ex) 주문, 취소

       

  - 발생 시점에 따른 엔터티 종류

    1. 기본 엔터티 : 키 엔터티라고 하며, 다른 엔터티에 영향을 받지 않는 독릭적인 엔터티 ex) 고객, 부서
    2. 중심 엔터티 : 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 엔터티 ex) 계좌, 주문
    3. 행위 엔터티 : 2개 이상의 엔터티로부터 발생되는 엔터티 ex) 주문이력

  <hr/>
### 속성(Attribute)

- 엔터티가 가지는 항목으로 의미적으로 더 이상 분해되지 않는다.
  
- 주 식별자에게 함수적으로 종속된다. 즉, 기본키가 변경되면 속성의 값도 변경된다.
  
- 종류
  
  - 분해 여부에 따른 속성의 종류
  
    1. 단일 속성 : 하나의 의미로 구성된 것 ex) 이름, ID
  
    2. 복합 속성 : 여러 개의 의미가 있는 것 ex) 주소(읍,면,리)
  
    3. 다중값 속성 : 여러 개의 값을 가질 수 있는 것 > 엔터티로 분해된다 ex) 상품 리스트
  
       
  
  - 특성에 따른 속성의 종류
  
    1. 기본 속성 : 프로세스에서 도출되는 본래의 속성 ex) 이름, ID
  
    2. 설계 속성 : 데이터 모델링 과정에서 발생되는 속성, 유일한 값을 가짐 ex) 상품코드
  
    3. 파생 속성 : 다른 속성에 의해서 만들어지는 속성 ex) 평균
  
       
  
- 도메인 : 속성이 가질 수 있는 값의 범위  ex) 성별 > 남자, 여자
  
<hr/>
### 관계(Relationship)

- 종류

  1. 존재 관계 : 엔터티 간의 상태를 의미. ex) 고객이 지점에 가입하면, 지점에서 고객을 관리한다.

  2. 행위 관계 : 엔터티 간에 행위가 있는 것 ex) 은행은 계좌를 개설한다.

     

- 관계 차수 종류

  - 1:1 관계

    1. 완전 1:1 관계 : 반드시 존재하며, 엔터티의 관계가 하나 있는 경우

    2. 선택적 1:1 관계 : 엔터티의 관계가 하나이거나 없는 수도 있는 경우

       ex) 한 명의 고객은 하나의 고객등급이 부여되며, 없을 수도 있다.

       

  - 1:N 관계 : 엔터티에 행이 하나 있을 때 다른 엔테티의 값이 여러 개 있는 경우

    ​		ex) 고객은 여러 개의 계좌를 가질 수가 있다.

    

  - M:N 관계 : 두 개의 엔터티가 서로 여러 개의 관계를 가지는 경우

    1. 필수적 관계(|) : 반드시 하나가 있어야 하는 관계

       ​	ex) 고객은 반드시 있어야 계좌를 개설할 수가 있다.

    2. 선택적 관계(O) : 없을 수도 있는 관계

       ​	ex) 고객은 있지만, 계좌가 없을 수도 있다.

       

  - 식별 관계

    - 고객과 계좌 엔터티에서 고객은 강한 개체이고, 계좌는 약한 개체이다.

    - 강한 개체는 다른 엔터티에 의존하지 않고 독립적으로 존재한다.

    - 강한 개체는 관계를 가질때 기본키를 공유하며, 식별관계(고객과 계좌의 회원ID를 공유)로 표현된다.

    - 강한 개체의 기본키 값이 변경되면 식별 관계에 있는 엔터티의 값도 변경된다.

      

  - 비식별 관계

    - 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것이다.
    - 점선으로 표현된다.

<hr/>
### 엔터티 식별자

- 주식별자(기본키, Primary key)

  - 유일성과 최소성을 만족하는 키이다

  - 엔터티를 대표할 수 있어야 한다.

  - 엔터티의 인스턴스를 유일하게 식별한다.

    

- 키의 종류

  1. 기본키(Primary key) : 후보키 중에서 엔터티를 대표할 수 있는 키

  2. 후보키(Candidate key) : 유일성과 최소성을 만족시키는 키

  3. 슈퍼키(Super key) : 유일성은 만족하지만, 최소성(Not Null)을 만족하지 않은 키

  4. 대체키(Alternate key) : 후보키 중에서 기본키를 뺀 나머지 키

     

- 식별자의 종류

  1. 식별자의 대표성

     - 주식별자 : 엔터티를 대표하는 식별자로 다른 엔터티와 참고 관계로 연결될 수가 있다.

     - 보조 식별자 : 유일성과 최소성을 만족하지만 대표성을 만족하지 못하는 식별자

       

  2.  생성여부

     - 내부 식별자 : 엔터티 내부에서 스스로 생성되는 식별자 ex) id, code

     - 외부 식별자 :  관계로 인하여 만들어지는 식별자

       

  3. 속성의 수

     - 단일 식별자 : 하나의 속성으로 구성

     - 복합 식별자 : 두 개 이상의 속성으로 구성

       

  4. 대체 여부

     - 본질 식별자 : 비즈니스 프로세스에서 만들어지는 식별자
     - 인조 식별자 : 인위적으로 만들어지는 식별자

<hr/><hr/>
### 정규화(Normalization)

- 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법

- 데이터의 일관성, 유연성을 위한 방법으로 데이터를 분해하는 과정이다.

- 정규화를 수행하지 않을 경우 이상현상이 발생할 수 있다.

- 정규화 절차

  1. 제1정규화 : 속성의 원자성을 확보하여 기본키를 설정한다.(식별자를 찾는 정도)
  2. 제2정규화 : 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거한다.
  3. 제3정규화 : 기본키를 제외한 칼럼 간에 종속성(이행 함수 종속성)을 제거한다.  ---- 실질적으로 여기까지 수행
  4. BCNF : 기본키를 제외한 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해한다.
  5. 제4정규화 : 다중 값 종속성을 제거한다.
  6. 제5정규화 : 조인에 의해서 종속성이 발생되는 경우 분해한다.

<hr/>
### 정규화 성능

- 정규화의 문제점 : 조회(SELECT)시 조인(JOIN)을 유발하여 CPU와 메모리를 많이 사용
- 성능 튜닝 : 위의 문제를 반정규화를 통해 해결가능하나 데이터 중복 등 여러 문제로인해 성능이 떨어질수 있음
- 적당히 조절해서 쓰라는 뜻인듯...

<hr/>
### 반정규화

- 데이터 중복을 허용하고 조인을 줄여 성능을 향상시키는 방법

- 조회(SELECT) 속도를 증가시키지만, 데이터 모델의 유연성은 낮아진다.

- 수행하는 경우

  1. 정규화에 충실했을 때 속도가 느려지는 경우

  2. 특정 범위의 데이터를 자주 처리하는 경우

  3. 요약/집계 정보가 자주 요구되는 경우

     

- 절차

  1. 대상 조사 및 검토 : 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다.
  2. 다른 방법 검토 : 클러스터링, 인덱스 튜닝, 파티션 등
  3. 반정규화 수행

- 클러스터링 : 인덱스 정보를 저장할 때 물리적으러 정렬해서 저장하는 방법

- 반정규화 기법

  1. 계산된 칼럼 추가 : 배치 프로그램으로 미리 계산하고, 특정 칼럼에 추가

  2. 테이블 수직분할 : 하나의 테이블을 두개 이상의 테이블로 분할

  3. 테이블 수평분할(파티션) : 하나의 테이블에 있는 값을 기준으로 분할

     - 논리적으로는 하나의 테이블이지만 분산되어 저장됨
     - Range Partition : 범위를 기준으로 파티션
     - List Partition : 특정 값을 지정하여 파티션
     - Hash Partition : 해시함수를 적용하여 파티션
     - Composite Partition : 범위와 해시함수를 복합적으로 사용하여 파티션
     - 장점 
       1. 조회 시 범위가 줄어 성능이 향샹됨
       2. 데이터가 분할되어 있어 IO 성능이 향샹됨
       3. 각 파티션을 독립적으로 백업 및 복구가 가능

  4. 테이블 병합

     - 1대1 관계의 테이블을 병합
     - 1댸N 관계의 테이블을 병합, 많은 양의 데이터 중복이 발생할 수 있음
     - 슈터타입과 서브타입 관계가 발생하면 병합

   
  
  - 슈퍼타입과 서브타입 
    - 부모와 자식 간의 관계, 즉 상속
    - 변환 방법
      1. OneToOne Type 
         - 슈퍼타입과 서브타입을 개별 테이블로 도출
         - 테이블 수가 많아서 조인이 많이 발생하고 관리가 어려움
      2. Plus Type 
         - 슈퍼타입과 서브타입 테이블로 도출
         - 조인이 발생하고 관리가 어려움
      3. Single Type 
         - 슈퍼 타입과 서브타입을 하나의 테이블로 도출
         - 조인 성능이 좋고 관리가 편하지만, IO성능이 나쁨
  
<hr/>

### 분산 데이터베이스

- 물리적으로 떨어진 DB를 네트워크로 연결하여 단일 DB 이미지를 보여 주며, 분산된 작업 처리를 하는것

- 사용자가 네트워크로 분산 여부를 인식하지 못하면서, 자기만의 DB를 사용하는 것처럼 보이는것이 투명성이며 이를제공 해야함

- 투명성의 종류

  1. 분할 투명성 : 논리적 릴레이션이 단편적으로 분할되어 있음을 고객은 인식할 필요가 없다.

  2. 위치 투명성: 저장 장소를 명시할 필요가 없으며, 동일한 명령을 하면 데이터 위치와 상관없이 접근 되어야 한다.

  3. 지역 사상 투명성 : 각 지역 시스템 이름과 무관한 이름이 사용 가능

  4. 중복 투명성 : 객체가 여러 시스템에 중복 존재해도, 데이터의 일관성이 유지된다.

  5. 장애 투명성 : 각 지역 시스템이나 통신망에 문제가 생겨도, 데이터의 무결성은 보장된다.

  6. 병행 투명성 : 동시에 분산 DB에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다.

     

- 설계 방식

  1. 상향식 설계 방식  : 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 DB를 구축
  2. 하향식 설계 방식  :  전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 DB를 구축

- 장단점

  - 장점
    1. 신뢰성과 가용성이 높음
    2. 병렬처리로 인한 빠른 응답
    3. 용량 확장이 용이
  - 단점
    1. 관리와 통제가 어려움
    2. 보안 관리가 어려움
    3. 설계가 복잡하며, 무결성 관리가 어려움


​     

​     

​     

  

